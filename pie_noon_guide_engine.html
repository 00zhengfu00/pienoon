<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Pie Noon: Pie Noon Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Pie Noon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pie_noon_guide_gameplay.html"><span>Gameplay</span></a></li>
      <li><a href="pie_noon_guide_overview.html"><span>Programmer's&#160;Guide</span></a></li>
      <li><a href="pie_noon_readme.html"><span>Readme</span></a></li>
      <li><a href="contributing.html"><span>Contributing</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pie_noon_guide_engine.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Pie Noon Engine </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="engine_introduction"></a>
Introduction</h1>
<p>This document outlines the engine components upon which the rest of Pie Noon is built.</p>
<h1><a class="anchor" id="engine_sdl"></a>
SDL</h1>
<p>We use <a href="https://www.libsdl.org/">SDL</a> (Simple Directmedia Layer) as our lowest level layer. SDL is an Open Source cross platform layer providing OpenGL context creation, input, and other things a game needs to run on a platform, without having to write any platform specific code. It has been in development for a long time, and has very robust support for mobile (Android, iOS), desktop (Windows, OS X, Linux), and even is available for the web through asm.js.</p>
<p>SDL together with OpenGL(ES) and C++ provide an excellent basis for making great cross platform games.</p>
<h1><a class="anchor" id="engine_components"></a>
Components</h1>
<p>Directly on top of SDL sit two systems, the renderer and input systems. On top of the renderer sits two more (optional) systems, material manager and the asynchronous loader.</p>
<p>The renderer also depends upon our <a href="http://google.github.io/mathfu">Pie Noon</a> library for all its vector and matrix datatypes. The (optional) material manager depends on our <a href="http://google.github.io/flatbuffers/">FlatBuffers</a> serialization library.</p>
<h1><a class="anchor" id="engine_renderer"></a>
Renderer</h1>
<p>The Renderer (<code><a class="el" href="renderer_8h_source.html">renderer.h</a>/.cpp</code>) is the core of the engine, and is responsible for creating the OpenGL context and OpenGL resources such as shaders and textures.</p>
<p>To actually represent these resources, we have:</p>
<ul>
<li><code>Shader</code> (<code><a class="el" href="shader_8h_source.html">shader.h</a>/.cpp</code>)</li>
<li><code>Mesh</code> (<code><a class="el" href="mesh_8h_source.html">mesh.h</a>/.cpp</code>)</li>
<li><code>Texture</code> / <code>Material</code> (<code><a class="el" href="material_8h_source.html">material.h</a>/.cpp</code>)</li>
</ul>
<p>The basic flow of using this lower level layer is as follows:</p>
<ul>
<li>Instantiate the <code>Renderer</code>, and call <code>Initialize</code> on it. This will get your OpenGL context set up, and a window/screen ready to draw on.</li>
<li>Load resources. <code>CompileAndLinkShader</code> will turn two shader strings (GLSL vertex and pixel shader) into a <code>Shader</code> object (for even more convenient methods that will load directly from file, see the material manager below). <code>LoadAndUnpackTexture</code> will take a file (currently TGA or WebP formats) and turn it into a raw buffer which <code>CreateTexture</code> turns into an OpenGL texture. Methods like this can generate complex errors, so whenever anything fails in the renderer, human readable errors are available in last_error().</li>
<li>Create a <code>Mesh</code>. You supply vertex data, and add one or more sets of indices referring to it with <code>AddIndices</code>.</li>
<li>Now you're ready to run your main loop. Call <code>AdvanceFrame</code> on the renderer to swap buffers and do general initialisation of the frame, likely followed by <code>ClearFrameBuffer</code>.</li>
<li>Before rendering anything, set up the renderer's <code>model_view_projection()</code>. Use our separate <a href="http://google.github.io/mathfu">Pie Noon</a> library to combine matrices depending on whether you're creating a 2D or 3D scene, e.g. <code>mathfu::OrthoHelper</code> and <code>mathfu::PerspectiveHelper</code>.</li>
<li>Now use the shader you've created by calling <code>Set</code> on it. This will make it active, and also upload any renderer variables (such as <code>model_view_projection()</code>), ready to be used by the shader.</li>
<li>Finally, calling <code>Render</code> on your mesh will display it on screen.</li>
</ul>
<h1><a class="anchor" id="engine_matman"></a>
Material Manager</h1>
<p>The renderer is deliberately a bare minimum system that takes care of creating and using resources, but not <em>managing</em> them. The material manager takes care of loading from disk, and caching resources, but is deliberately seperate from the renderer, such that it is easy to replace with something else should the need arise.</p>
<p>Where the renderer reads from memory buffers, the material manager loads files. To keep this cross platform, any resources should be in a folder called <code>assets</code> under the project root. All paths you specify are relative to this folder.</p>
<p>Once you've instantiated the <code>MaterialManager</code>, calls like <code>LoadShader</code> will conveniently construct a <code>Shader</code> from two files. It does this by suffixing <code>.glslv</code> and <code>.glslf</code> to the filename you pass.</p>
<p>Similarly, <code>LoadTexture</code> will load a TGA or WebP file straight into a <code>Texture</code>.</p>
<p>All methods that start with <code>Load</code> have the property that if you ask to load a file that has been loaded before, it just instantly return the previously created resource, and only do any actual loading if not.</p>
<p>Alternatively, there are <code>Find</code> versions of these methods that will return <code>nullptr</code> if the resource wasn't previously loaded.</p>
<p>More high-level than loading individual textures is loading a <code>Material</code>, which is a set of textures all meant to be used in the same draw call, bundled with rendering flags such as the desired alpha blending mode etc. You create an actual material file by writing a small .json file which specifies the texture filenames and other properties. This JSON file can be converted to a binary file by our <a href="http://google.github.io/flatbuffers/">FlatBuffers</a> serialization library, the result of which can be passed to <code>LoadMaterial</code> that will load all referenced textures and create a <code>Material</code> object (which can be attached to <code>Mesh</code>).</p>
<h1><a class="anchor" id="engine_async_loader"></a>
Asynchronous Loader</h1>
<p>Loading resources can take a long time, and can be sped up by loading heavy resources (such as textures, WebP in particular) in parallel with the rest of the game initialisation. Even if speed is not the issue, just being able to conveniently render a loading animation is nice to have.</p>
<p><code>AsyncLoader</code> takes care of all that, hiding the gory details of threading from you. It is fully integrated with the material manager, so using it is relatively simple:</p>
<ul>
<li>Load all your resources as normal. You will receive <code>Texture</code> and <code>Material</code> objects, but these won't actually have any texture data associated with them yet, as textures haven't loaded yet.</li>
<li>Once you've queued up all your resources, call <code>StartLoadingTextures</code> on the material manager to get the loading started.</li>
<li>Now, enter your frame loop as normal. Call <code>TryFinalize</code> which will check if all textures have been loaded. If it returns false, you should display a loading screen, otherwise render the game as normal.</li>
<li>Your loading screen might want to use textures also. Since the loader loads textures in the order they were requested, make sure you queue up your loading screen textures first. If the <code>Texture::id()</code> is non-zero, it can already be used.</li>
</ul>
<h1><a class="anchor" id="engine_input"></a>
Input System</h1>
<p><code>InputSystem</code> (<code><a class="el" href="input_8h_source.html">input.h</a>/.cpp</code>) deals with time, touch/mouse/keyboard/gamepad input, and lifecycle events.</p>
<p>Similar to the renderer, instantiate it, then call <code>Initialize</code>, and once per frame call <code>AdvanceFrame</code> right after you called the same method on the renderer. This collects new input events from the system to be reflected in its internal state.</p>
<p>Call <code>Time</code> for seconds since game start, and <code>DeltaTime</code> for seconds since the last frame.</p>
<p>Now you can query the state of the inputs you're interested in. For example, call <code>GetButton</code> with one of the constants from <code><a class="el" href="input_8h_source.html">input.h</a></code> which can either be a keyboard key, or a pointer (meaning the mouse or touch inputs, depending on platform) or a gamepad button, and you can see if it went down or up this last frame, or wether it is currently down. The <code>Pointer</code> objects can tell you more about their current position.</p>
<p>The Pie Noon game does not normally process input events directly, but rather passes them through to the <a class="el" href="pie_noon_guide_controllers.html">Controller</a> system, where they are normalized into a common set of inputs that is independent of the physical input device. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-46159502-1', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>
