// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include "splat_common.fbs";
include "audio_config.fbs";

namespace fpl.splat;

enum Orientation : ushort {
  Verticle,
  Horizontal
}

table Splatter {
  // Location for the splatter texture to appear.
  location:Vec2i;

  // Size of the splatter texture. 1 is size as authored, >1 is bigger, <1 is
  // smaller.
  scale:Vec2;

  // Which renderable should be used for this splotch.
  renderable:RenderableId;
}

struct Prop {
  // The object to render. See RenderableId enum.
  // TODO: change to ushort once padding warning is fixed.
  renderable:uint;

  // Placement of the object.
  position:Vec3;

  // Rotation about the vertical axis, in degrees.
  rotation:float;

  // Initial rotation we should apply, before performing 'rotation'.
  orientation:Orientation;

  // Scale along each axis. Scale is performed before rotation.
  scale:Vec3;
}

struct CharacterData {
  // Where the character should be placed in the world.
  position:Vec3;

  // 1 if left turns clockwise, -1 if left turns counter-clockwise.
  // Intuitive controls depend on layout of surrounding characters.
  left_jump:int;

  // TODO: Add color here?
}

table RenderableDef {
  // The id used around the game to describe what needs to be rendered.
  // The things we render in our scene are simple. They all can be described
  // by the data structure here.
  id:RenderableId;

  // Texture for the front of the cardboard cutout.
  cardboard_front:string;

  // Texture for the inside surface of the cardboard cutout. That is, showing
  // the corrugations.
  cardboard_back:string;

  // Horizontal displacement of the renderable. Used to keep the characters
  // centered around the stick that props them up, while keeping the stick
  // stationary.
  offset:Vec3;

  // True if the renderable should have a popsicle stick propping it up.
  stick:bool = false;

  // True if the renderable should cast shadows.
  shadow:bool = false;
}

// Each arrangement should have it a unique number of players How many people
// are playing determines the arrangement to use.
table CharacterArrangement {
  character_data:[CharacterData];
}

table Config {
  // Temporary variable to control number of players until we can configure it
  // from in the game
  character_count:uint;

  // Different configurations of players.
  character_arrangements:[CharacterArrangement];

  // Audio engine configuration.
  audio:AudioConfig;

  // Where the camera should be positioned.
  camera_position:Vec3;

  // Where the camera should be pointed at.
  camera_target:Vec3;

  // The positions of the light sources.
  light_positions:[Vec3];

  // How much health a player has. Some pies may do more damage than others.
  character_health:int;

  // How long it takes for a pie to reach it's target. Note that this is not
  // the same as speed; throwing a pie at someone diagonal to you will take the
  // same amount of time as throwing a pie at someone adjacent to you.
  pie_flight_time:int;

  // The height of the pie arc when thrown.
  pie_arc_height:float;

  // Randomly adjusts how high the pie is thrown. e.g. A value of 2 would mean
  // the pie could have any height between `pie_height - 2` to `pie_height + 2`
  // with equal probability.
  pie_arc_height_variance:float;

  // The height of the pie at the start (and end) of it's arc.
  pie_initial_height:float;

  // The number of in-air spins the pie should have.
  pie_rotations:int;

  // Randomly adjusts how much the pie spins in the air. e.g. A value of 2
  // would mean the pie could have any whole number of rotations between
  // `pie_rotations - 2` to `pie_rotations + 2` with equal probability.
  pie_rotation_variance:int;

  // The initial angle of the pie when thrown, in degrees.
  pie_initial_angle:float;

  // The target angle of the pie when landing, in degrees.
  pie_target_angle:float;

  // The maximum and minimum duration a frame can last.
  min_update_time:int;
  max_update_time:int;

  // These values can be tuned to adjust the turning speed and wobble when
  // changing targets.
  //
  // Acceleration is a multiple of the face angle error. Bigger values make
  // the character accellerate faster. In (radians/tick/tick) / radians.
  face_delta_to_accel:float;

  // When accelerating away from the target, we multiply our acceleration by
  // this amount. We need counter-acceleration to be stronger so that the
  // amplitude eventually dies down.
  face_wrong_direction_accel_bonus:float;

  // Maximum angular velocity that the character can spin.
  face_max_velocity:float;

  // Cutoff to determine if the character face angle is pretty well at target.
  // Once below the cutoff, the character's face angle is clamped to target.
  // In radians/tick.
  face_near_target_angular_velocity:float;

  // Cutoff to determine if the chracter's face angle is pretty well at target.
  // In radians.
  face_near_target_angle:float;

  // The id of the first pie and last pie. Intermediate pie material id's are
  // assumed to be in between these two ids.
  first_airborne_pie_renderable:RenderableId;
  last_airborne_pie_renderable:RenderableId;

  // Rendering constants.
  //
  // Size of the target screen. In pixels.
  window_size:Vec2i;

  // Name of the target window. Used on desktop platforms.
  window_title:string;

  // Field of view angle for the camera.
  viewport_angle:float;

  // Aspect ratio of the camera. Should match the window_size aspect ratio for
  // proper rendering.
  viewport_aspect_ratio:float;

  // Objects closer than the near plane are clipped.
  viewport_near_plane:float;

  // Object farther than the far plane are culled.
  viewport_far_plane:float;

  // Constant conversion from texture to world space.
  pixel_to_world_scale:float;

  // The depth of the front plane. Negative means nearer.
  cardboard_front_z_offset:float;

  // The depth of the back plane (with the corrugations).
  cardboard_back_z_offset:float;

  // The distance in front of the character of the first accessory.
  accessory_z_offset:float;

  // The distance added to each successive accessory, so that the accessories
  // don't overlap.
  accessory_z_increment:float;

  // Keep the cardboard cutouts facing the stage front.
  // Bigger numbers increase the effect. A number of 1 eliminates all effect.
  cardboard_bias_towards_stage_front:float;

  // The vertical offset of the popsicle stick prop.
  stick_y_offset:float;

  // The depth of the front of the popsicle stick from the front of the
  // cardboard.
  stick_front_z_offset:float;

  // The depth of the back of the popsicle stick from the back of the cardboard.
  // Should be bigger than stick_z_offset, and smaller than
  // cardboard_back_z_offset.
  stick_back_z_offset:float;

  // Texture for the front of the stick. The cutouts are mounted on the stick.
  stick_front:string;

  // Texture for the inside of the stick. Rendered similar to 'cardboard_back'.
  stick_back:string;

  // The UI arrow points at the character's target. We allow it to follow the
  // face angle, too, but only up to a small deviation from the target angle.
  // In degrees.
  ui_arrow_max_diff_from_target:float;

  // Offset of UI arrow from the character. Z is forward. X is side. Y is up.
  ui_arrow_offset:Vec3;

  // Scale of UI arrow from it's authored size. Z is length. X is width.
  ui_arrow_scale:Vec3;

  // Where splatter splotches should appear on a character. One splotch appears
  // per point of damage taken.
  splatter:[Splatter];

  // Initial configuration of stage and environment.
  props:[Prop];

  // Describe the model for each item that can be rendered.
  // Array of length RenderableId_Count.
  renderables:[RenderableDef];

  // Debug options
  //
  // Continuously draw this renderable at the origin. Useful for debugging one
  // renderable.
  draw_fixed_renderable:RenderableId;

  // Put the characters into the scene description.
  draw_characters:bool;

  // Put the targeting arrows into the scene description.
  draw_ui_arrows:bool;

  // Put the airborne pies into the scene description.
  draw_pies:bool;

  // Put the environment into the scene description.
  draw_props:bool;

  // Put a series of objects along the positive x, y, and z axes.
  draw_axes:bool;

  // Translate mouse movement to camera xz movement in the world.
  mouse_to_ground_scale:float;

  // Translate mouse movement to camera y movement in the world.
  mouse_to_height_scale:float;

  // Translate mouse movement to camera rotation in the world.
  mouse_to_camera_rotation_scale:float;

  // Print out character states whenever a transition happens.
  print_character_states:bool;

  // Print out pie movement when they are airborne.
  print_pie_states:bool;
}

root_type Config;
