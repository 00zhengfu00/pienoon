// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include "splat_common.fbs";
include "audio_config.fbs";
include "impel.fbs";
include "particles.fbs";

namespace fpl.splat;

enum Orientation : ushort {
  Verticle,
  Horizontal
}

enum PieDeflectionMode : ushort {
  ToTargetOfTarget,
  ToSource,
  ToRandom
}

enum ButtonInputType : ushort (bit_flags) {
  Left,
  Right,
  Attack,
  Defend
}

// Used for defining zones for the touch controller.
// the touch screen, (1, 1) is the lower right.  Input_type is what input
// action should be associated with touching that zone.
// texture_normal and texture_down show which textures are used to represent
// the touch-zone in its normal state and when it's being pressed.
table ButtonDef {
  // These are used to demarcate the zone boundaries,
  // Coordinate values can range from 0-1.  (0,0) represents the upper
  // left corner of the touch screen, (1, 1) is lower right.
  top_left : Vec2;
  bottom_right : Vec2;

  // Which action is triggered by touching this zone.
  input_type : ButtonInputType;

  // Material to display for the touch zone, both in its normal
  // state, and when it is registering a press.
  texture_normal : string;
  texture_pressed : string;
  draw_scale_normal: Vec2;
  draw_scale_pressed: Vec2;

  // Position to draw the texture at:
  // (Designates the center of the texture, and like the zone boundaries, is
  // expressed as a fraction of the screen width/height.)
  texture_position : Vec2;
}

table FixedAccessory {
  // Location for the splatter texture to appear.
  location:Vec2i;

  // Size of the splatter texture. 1 is size as authored, >1 is bigger, <1 is
  // smaller.
  scale:Vec2;

  // Which renderable should be used for this splotch.
  renderable:RenderableId;
}

table AccessoryGroup {
  // Indices into an array of FixedAccessory's.
  indices:[byte];
}

table Prop {
  // The object to render. See RenderableId enum.
  // TODO: change to ushort once padding warning is fixed.
  renderable:uint;

  // Placement of the object.
  position:Vec3;

  // Rotation about the vertical axis, in degrees.
  rotation:float;

  // Initial rotation we should apply, before performing 'rotation'.
  orientation:Orientation;

  // Scale along each axis. Scale is performed before rotation.
  scale:Vec3;
}

table CharacterData {
  // Where the character should be placed in the world.
  position:Vec3;

  // 1 if left turns clockwise, -1 if left turns counter-clockwise.
  // Intuitive controls depend on layout of surrounding characters.
  left_jump:int;

  // TODO: Add color here?
}

table CardboardFigure {
  // The id used around the game to describe what needs to be rendered.
  // The things we render in our scene are simple. They all can be described
  // by the data structure here.
  id:RenderableId;

  // Material for the front of the cardboard cutout.
  cardboard_front:string;

  // Material for the inside surface of the cardboard cutout. That is, showing
  // the corrugations.
  cardboard_back:string;

  // Horizontal displacement of the renderable. Used to keep the characters
  // centered around the stick that props them up, while keeping the stick
  // stationary.
  offset:Vec3;

  // Optionally specify bounding box around geometry.
  // x-coordinate is width. y-coordinate is height.
  // Texture origin is at the bottom, in the middle, so
  //   bottom: 0
  //   top: pixel_bounds.y
  //   left: -pixel_bounds.x / 2
  //   right: pixel_bounds.x / 2
  // If left as the default nullptr, bounding box is ignored.
  pixel_bounds:Vec2i;

  // Scale the cardboard geometry. We convert from pixel-size to world-size by
  // multiplying geometry_scale * pixel_to_world_scale (see below).
  geometry_scale:float = 1.0;

  // True if the renderable should have a popsicle stick propping it up.
  stick:bool = false;

  // True if the renderable should cast shadows.
  shadow:bool = false;

  // True if renderable is made of cardboard (has the cardboard normalmap).
  cardboard:bool = false;

  // Offset to the splatter accessories, in pixels.
  splatter_offset:Vec2i;

  // Offset to health accessories (i.e. hearts), in pixels.
  health_offset:Vec2i;
}

// Each arrangement should have it a unique number of players How many people
// are playing determines the arrangement to use.
table CharacterArrangement {
  character_data:[CharacterData];
}

table TwoDimensionalElement {
  // Render first texture in this material.
  material:string;

  // Size of the screen to occupy, as a multiple of height.
  //    0.1 --> height is 10% of screen
  size:float;

  // Location of image on screen.
  //   0 --> far left (or top).
  //   1 --> far right (or bottom).
  placement:Vec2;
}

table Config {
  // Temporary variable to control number of players until we can configure it
  // from in the game
  character_count:uint;

  // Different configurations of players.
  character_arrangements:[CharacterArrangement];

  // Number of players to start assigned to keyboard control:
  number_of_keyboard_controllers:uint;

  // Character primary colors.
  character_colors:[Vec3];

  // Color to draw AIs.
  ai_color:Vec3;

  // This modulates the primary colors
  character_global_brightness_factor:float;

  // Audio engine configuration.
  audio:AudioConfig;

  // Where the camera should be positioned.
  camera_position:Vec3;

  // Where the camera should be pointed at.
  camera_target:Vec3;

  // The positions of the light sources.
  light_positions:[Vec3];

  // How much health a player has. Some pies may do more damage than others.
  character_health:int;

  // How long it takes for a pie to reach it's target. Note that this is not
  // the same as speed; throwing a pie at someone diagonal to you will take the
  // same amount of time as throwing a pie at someone adjacent to you.
  pie_flight_time:int;

  // The height of the pie arc when thrown.
  pie_arc_height:float;

  // Randomly adjusts how high the pie is thrown. e.g. A value of 2 would mean
  // the pie could have any height between `pie_height - 2` to `pie_height + 2`
  // with equal probability.
  pie_arc_height_variance:float;

  // The height of the pie at the start (and end) of it's arc.
  pie_initial_height:float;

  // The number of in-air spins the pie should have.
  pie_rotations:int;

  // Randomly adjusts how much the pie spins in the air. e.g. A value of 2
  // would mean the pie could have any whole number of rotations between
  // `pie_rotations - 2` to `pie_rotations + 2` with equal probability.
  pie_rotation_variance:int;

  // The initial angle of the pie when thrown, in degrees.
  pie_initial_angle:float;

  // The target angle of the pie when landing, in degrees.
  pie_target_angle:float;

  // Where the pie should be directed when deflected.
  pie_deflection_mode:PieDeflectionMode;

  // When pie is deflected, the amount of damage the pie will inflict is
  // changed by this amount. This allows the pies to shrink and eventually
  // disappear (if the value is negative).
  pie_damage_change_when_deflected:int;

  // The minimum duration a frame can last regardless of how fast the
  // processor is. In ms.
  // For example, if 10ms, game cannot go faster than 100Hz. The game won't
  // look much smoother or play better at faster frame rates. We'll just be
  // hogging the CPU.
  min_update_time:int;

  // The maximum duration a frame can last regardless of how slow the
  // processor is. In ms.
  // For example, if 100ms, game cannot jump more than 100ms in one simulation
  // update. If we're debugging, or a task switch happens, we'll get
  // super-large update times that we'd rather just ignore.
  max_update_time:int;

  // Defines the turning speed and wobble of the character's face angle, when
  // changing targets.
  face_angle_def:OvershootParameters;
  face_angle_twitch:Settled1fParameters;
  face_angle_twitch_velocity:float;

  // Map airborne pie damage to the renderable id of the pie.
  renderable_id_for_pie_damage:[RenderableId];

  // After the game is finished, minimal time before we can reset and start
  // playing again. In ms.
  play_finished_timeout:int;

  // Rendering constants.
  //
  // Size of the target screen. In pixels.
  window_size:Vec2i;

  // Name of the target window. Used on desktop platforms.
  window_title:string;

  // Field of view angle for the camera.
  viewport_angle:float;

  // Aspect ratio of the camera. Should match the window_size aspect ratio for
  // proper rendering.
  viewport_aspect_ratio:float;

  // Objects closer than the near plane are clipped.
  viewport_near_plane:float;

  // Object farther than the far plane are culled.
  viewport_far_plane:float;

  // Constant conversion from texture to world space.
  pixel_to_world_scale:float;

  // The depth of the front plane. Negative means nearer.
  cardboard_front_z_offset:float;

  // The depth of the back plane (with the corrugations).
  cardboard_back_z_offset:float;

  // The distance in front of the character of the first accessory.
  accessory_z_offset:float;

  // The distance added to each successive accessory, so that the accessories
  // don't overlap.
  accessory_z_increment:float;

  // Keep the cardboard cutouts facing the stage front.
  // Bigger numbers increase the effect. A number of 1 eliminates all effect.
  cardboard_bias_towards_stage_front:float;

  // Cardboard lighting properties:
  cardboard_ambient_material:Vec3;
  cardboard_diffuse_material:Vec3;
  cardboard_specular_material:Vec3;
  cardboard_shininess:float;

  // The vertical offset of the popsicle stick prop.
  stick_y_offset:float;

  // The depth of the front of the popsicle stick from the front of the
  // cardboard.
  stick_front_z_offset:float;

  // The depth of the back of the popsicle stick from the back of the cardboard.
  // Should be bigger than stick_z_offset, and smaller than
  // cardboard_back_z_offset.
  stick_back_z_offset:float;

  // Material for the front of the stick. The cutouts are mounted on the stick.
  stick_front:string;

  // Material for the inside of the stick. Rendered similar to
  // 'cardboard_back'.
  stick_back:string;

  // Offset of UI arrow from the character. Z is forward. X is side. Y is up.
  ui_arrow_offset:Vec3;

  // Scale of UI arrow from it's authored size. Z is length. X is width.
  ui_arrow_scale:Vec3;

  // Map damage to sets of accessories. That is splatter_map[damage] is the set
  // indices into splatter_accessories[] that should be rendered when the
  // character has taken 'damage' amount of damage.
  splatter_map:[AccessoryGroup];

  // Where splatter splotches should appear on a character. One splotch appears
  // per point of damage taken.
  splatter_accessories:[FixedAccessory];

  // Map health to sets of accessories. That is, health_map[health] is the set
  // of indices into health_accessories[] that should be rendered when the
  // character has 'health' remaining.
  health_map:[AccessoryGroup];

  // Where hearts should appear on a character. One heart appears per point of
  // health remaining.
  health_accessories:[FixedAccessory];

  // Initial configuration of stage and environment.
  props:[Prop];

  // Describe the model for each item that can be rendered.
  // Array of length RenderableId_Count.
  renderables:[CardboardFigure];

  // Definition for pie splatter particles:
  pie_splatter_def:ParticleDef;
  splat_particles_per_damage:int;

  // Confetti for the victor.
  confetti_def:ParticleDef;

  // AI options
  ai_minimum_time_between_actions:int;
  ai_maximum_time_between_actions:int;
  ai_chance_to_block:float;
  ai_chance_to_change_aim:float;
  ai_chance_to_throw:float;

  // UI options
  //
  // Touchscreen controller layout:
  touchscreen_zones:[ButtonDef];

  // Splash screen, etc.
  two_dimensional_elements_for_finished_state:[TwoDimensionalElement];

  // Debug options
  //
  // Put the characters into the scene description.
  draw_characters:bool;

  // Put the targeting arrows into the scene description.
  draw_ui_arrows:bool;

  // Put the airborne pies into the scene description.
  draw_pies:bool;

  // Put the environment into the scene description.
  draw_props:bool;

  // Put a series of objects along the positive x, y, and z axes.
  draw_axes:bool;

  // Draw all character renderables in a line.
  draw_character_lineup:bool;

  // Draw splatters and hearts of lineup characters. Does nothing unless
  // draw_character_lineup is true.
  draw_lineup_accessories:bool;

  // Continuously draw this renderable at the origin. Useful for debugging one
  // renderable.
  draw_fixed_renderable:RenderableId;

  // When button pressed, how far to translate the camera in the world.
  button_to_camera_translation_scale:Vec3;

  // Translate mouse movement to camera rotation in the world.
  mouse_to_camera_rotation_scale:float;

  // Move the camera when mouse buttons are pressed.
  allow_camera_movement:bool;

  // Print out character states whenever a transition happens.
  print_character_states:bool;

  // Print out pie movement when they are airborne.
  print_pie_states:bool;

  // Print out the camera position or target whenever they change.
  print_camera_orientation:bool;
}

root_type Config;
